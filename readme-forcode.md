```markdown
# Полное техническое пояснение кода графопостроителя

## 1. Общая архитектура
Программа состоит из 4 основных модулей:
1. **Токенизация** - разбор строки на элементы
2. **Shunting Yard** - преобразование в обратную польскую запись
3. **Вычисление RPN** - интерпретатор выражений
4. **Отрисовка графика** - визуализация в терминале

```c
main() → Tokenize() → ShuntingYard() → EvaluateRPN() → PlotGraph()
```

## 2. Система типов и структуры данных

### Токен (Token)
```c
typedef struct {
    TokenType type;    // Тип элемента (число, оператор и т.д.)
    char value[20];    // Строковое представление
    double number;     // Численное значение (для чисел)
} Token;
```
Типы токенов:
- `NUMBER`: Числа (3.14, -5)
- `VARIABLE`: Переменная x
- `OPERATOR`: +, -, *, /, ^, унарный минус (u-)
- `FUNCTION`: sin, cos, tan, ctg, sqrt, ln
- `PAREN`: Скобки

## 3. Детальное описание ключевых функций

### 3.1 Токенизация (Tokenize)
**Алгоритм:**
1. Пропуск пробелов
2. Определение типа текущего символа:
   - Числа: `isdigit()` или точка
   - Буквы: функции или переменные
   - Операторы: +-*/^
   - Скобки: ()
3. Заполнение буфера токенов

**Особенности:**
- Обработка унарного минуса через флаг `last_was_operator_or_paren`
- Разделение чисел с плавающей точкой (MyAtof)
- Проверка на неизвестные функции

### 3.2 Shunting Yard Algorithm
**Цель:** Преобразование инфиксной записи в постфиксную (RPN)

**Правила обработки:**
1. Числа и переменные сразу в выходную очередь
2. Функции и левые скобки в стек
3. Операторы выталкивают из стека операторы с высшим приоритетом
4. Правая скобка выталкивает до левой скобки

**Приоритеты операторов:**
```c
1: + -
2: * /
3: ^ 
4: унарный минус и функции
```

### 3.3 Вычисление RPN (EvaluateRPN)
**Стековая машина:**
- Числа кладутся в стек
- Операторы берут значения из стека
- Функции применяются к верхнему элементу стека

**Пример выполнения:**
```
Выражение: 3 4 2 * +
Шаги:
1. Push 3 → [3]
2. Push 4 → [3, 4]
3. Push 2 → [3, 4, 2]
4. Умножить 4*2 → [3, 8]
5. Сложить 3+8 → [11]
```

### 3.4 Отрисовка графика (PlotGraph)
**Этапы:**
1. Создание сетки 80x25 символов
2. Расчет Y для каждого X:
   ```c
   x = X_MIN + j*(X_MAX-X_MIN)/(WIDTH-1)
   ```
3. Преобразование координат:
   ```c
   screen_y = round((Y_MAX - y) * (HEIGHT-1) / (Y_MAX - Y_MIN))
   ```
4. Соединение точек линиями:
   - Интерполяция между соседними точками
   - Заполнение промежуточных значений

## 4. Математические функции

### 4.1 Реализации рядов Тейлора
**Синус:**
```c
double MySin(double x) {
    // Нормализация угла в диапазон [-π, π]
    // Разложение в ряд: x - x³/3! + x⁵/5! - ...
    for (int i = 1; i <= 15; i += 2) {
        term = -term * x² / (i+1)/(i+2);
        result += term;
    }
}
```

**Косинус:**
```c
double MyCos(double x) {
    // Аналогично синусу, но начинаем с 1
    term = 1.0;
    for (int i = 0; i <= 14; i += 2) {
        term = -term * x² / (i+1)/(i+2);
        result += term;
    }
}
```

### 4.2 Метод Ньютона для корня
```c
double MySqrt(double x) {
    guess = x/2;
    for (20 итераций) {
        guess = 0.5*(guess + x/guess);
    }
}
```

## 5. Обработка ошибок
**Критические ошибки:**
- Несбалансированные скобки
- Неизвестные символы в выражении
- Пустой стек при вычислениях

**Особые случаи:**
```c
// Деление на ноль
if (b.number ≈ 0) → результат infinity

// Логарифм неположительного числа
if (x <= 0) → NaN

// Касательная в π/2
if (cos(x) ≈ 0) → infinity
```

## 6. Оптимизации и ограничения

### Производительность:
- Фиксированный размер стека (80x25)
- Ограничение итераций в математических функциях
- Линейный проход по токенам

### Точность:
- Округление при отрисовке
- Ограничение рядов Тейлора 15-20 членами
- Эпсилон-сравнение для чисел с плавающей точкой

## 7. Расширение функционала

**Добавление новой функции:**
1. Реализовать вычисление (например, exp)
2. Добавить в TokenType
3. Обновить IsFunction()
4. Добавить обработку в EvaluateRPN()

**Пример добавления экспоненты:**
```c
// В Tokenize
else if (strcmp(token, "exp") == 0) → FUNCTION

// В EvaluateRPN
else if (strcmp(token.value, "exp") == 0) {
    result.number = MyExp(a.number);
}

// Реализация MyExp
double MyExp(double x) {
    // Реализация через ряд Тейлора
}
```

## 8. Отладка и тестирование

**Тестовые сценарии:**
```bash
# Проверка базовых операций
./graph "x"              # Прямая линия
./graph "sin(x)"         # Синусоида
./graph "sqrt(x)"        # Парабола

# Проверка ошибок
./graph "sin(x"          # Несбалансированные скобки
./graph "x + unknown"    # Неизвестная функция
```

Этот код представляет собой законченное решение для построения простых графиков в терминале, демонстрируя ключевые концепции:
- Лексический анализ
- Алгоритмы работы со стеком
- Численные методы
- Текстовый вывод с псевдографикой
```
